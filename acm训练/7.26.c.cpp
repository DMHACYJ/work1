/*
题目描述
喵星发布了一种新型钞票，这种钞票有正有负，给定一个长度为k的钞票序列，然后红红通过数钞票来获得钞票，但是红红有一个怪癖，他仅仅只是拥有连续的记忆，意思就是他只能连续计数，但是红红想要获得尽可能多的钱，但是红红做不到。你可以帮帮红红吗？


举个例子，给定钞票序列是{-2 11 -4 13 -5 -2} 而红红去数的最大子序列就是就是{11 -4 13 } 

所以红红能够获得最多钱为20。


现在请你来帮助红红早日发家致富。

输入
每一个样例包含一组数据。每一组数据包含两行。

第一行包含一个正整数k(<=10000)。

第二行包含K个数，每一个数中间用空格隔开。

输出
对于每一个样例输出，都输出一行。

这一行的第一个数字就是最大的和

后面两个数 就是这个钞票序列的起始的数i和 终止的数 

这些数字必须以空格相隔开，并且在每一行的末尾没有额外的空格。

另外 可能这个最大的钞票序列往往并不是唯一的，所以只需要输出包含最小的起始坐标或者终止坐标。

注意 如果所有的数全部都是负数，那么其的最大钞票和为0，且你应该输出的是从这整个序列第一个数到最后一个数。*/
#include<iostream>
#include<cstring>
using namespace std;
int a[10010];
int main()
{
	int k;
	cin>>k;
	
	for(int i=0;i<k;i++)
	{
		cin>>a[i];
	}
	int left=0;
	int tmpleft=0;
	int right=k-1;
	int sum=0;
	int Max=-1;
	for(int i=0;i<k;i++)
	{
		sum+=a[i];
		cout<<"a"<<endl;
		if(sum<0)
		{
			sum=0;
			tmpleft=i+1;
		}
		else if(sum>Max)
		{
			Max=sum;
			right=i;
			left=tmpleft;
		}
	}
	if(Max>=0) 
	{
		cout<<Max<<" "<<a[left]<<" "<<a[right]<<endl;
	}
	else cout<<"0"<<" "<<a[0]<<" "<<a[k-1]<<endl;
	return 0;
}
