/*
题目描述
在ACM可以做任何事情之前，必须准备预算并获得必要的财务支持。此行动的主要收入来自不可逆转的捆绑资金（IBM）。背后的想法很简单。每当一些ACM成员有任何小钱时，他就拿走所有硬币并将它们扔进存钱罐。你知道这个过程是不可逆转的，硬币不能在不打破猪的情况下被移除。经过足够长的时间后，存钱罐中应该有足够的现金来支付需要支付的所有费用。
但是存钱罐存在很大问题。无法确定内部有多少钱。因此，我们可能会将猪分成碎片，但却发现没有足够的钱。显然，我们希望避免这种不愉快的情况。唯一的可能性是称重存钱罐并试图猜测里面有多少硬币。假设我们能够确切地确定猪的重量并且我们知道给定货币的所有硬币的重量。然后，我们可以保证在存钱罐中有一些最低金额。你的任务是找出最坏的情况，并确定存钱罐内的最低现金数量。我们需要你的帮助。不再过早破猪！

输入
输入由T个测试用例组成。它们的数量（T）在输入文件的第一行给出。每个测试用例都以包含两个整数E和F的行开头。它们表示空猪和装满硬币的猪的重量。两种重量均以克为单位。没有猪的体重超过10公斤，这意味着1 <= E <= F <= 10000.在每个测试用例的第二行，有一个整数N（1 <= N <= 500）给出各种数量以给定货币使用的硬币。在此之后正好是N行，每行指定一种硬币类型。这些行包含两个整数，每个Pand W（1 <= P <= 50000 1 <= W <= 10000）。P是以货币单位表示的硬币值W是以克为单位的重量。
输出
为每个测试用例打印一行输出。该行必须包含句子“存钱罐中的最小金额是X.” 其中X是使用给定总重量的硬币可以实现的最小金额。如果无法达到重量，请准确打印一行“这是不可能的”。*/
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
	int t;
	cin>>t;
	int p[505];
	int w[505];
	int pw[10000];
	while(t--)
	{
		memset(p,0,sizeof(p));
		memset(w,0,sizeof(w));
		memset(pw,0x3f3f3f3f,sizeof(pw));
		int e,f,n;
		cin>>e>>f;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>p[i]>>w[i];
		}
		pw[0]=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=w[i];j<=f-e;j++)
			{
				pw[j]=min(pw[j],pw[j-w[i]]+p[i]);
			}
		}
		if(pw[f-e]!=0x3f3f3f3f)
			cout<<"The minimum amount of money in the piggy-bank is "<<pw[f-e]<<"."<<endl;
		else cout<<"This is impossible."<<endl;
	}
	return 0;
}
